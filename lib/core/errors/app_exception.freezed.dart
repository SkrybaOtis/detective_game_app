// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'app_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$AppException {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AppException);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AppException()';
}


}

/// @nodoc
class $AppExceptionCopyWith<$Res>  {
$AppExceptionCopyWith(AppException _, $Res Function(AppException) __);
}


/// Adds pattern-matching-related methods to [AppException].
extension AppExceptionPatterns on AppException {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( FileNotFoundException value)?  fileNotFound,TResult Function( FileReadErrorException value)?  fileReadError,TResult Function( FileWriteErrorException value)?  fileWriteError,TResult Function( InvalidJsonException value)?  invalidJson,TResult Function( EpisodeNotFoundException value)?  episodeNotFound,TResult Function( LocationNotFoundException value)?  locationNotFound,TResult Function( CharacterNotFoundException value)?  characterNotFound,TResult Function( ClueNotFoundException value)?  clueNotFound,TResult Function( EnigmaNotFoundException value)?  enigmaNotFound,TResult Function( InvalidQrCodeException value)?  invalidQrCode,TResult Function( PermissionDeniedException value)?  permissionDenied,TResult Function( NetworkErrorException value)?  networkError,TResult Function( UnknownException value)?  unknown,required TResult orElse(),}){
final _that = this;
switch (_that) {
case FileNotFoundException() when fileNotFound != null:
return fileNotFound(_that);case FileReadErrorException() when fileReadError != null:
return fileReadError(_that);case FileWriteErrorException() when fileWriteError != null:
return fileWriteError(_that);case InvalidJsonException() when invalidJson != null:
return invalidJson(_that);case EpisodeNotFoundException() when episodeNotFound != null:
return episodeNotFound(_that);case LocationNotFoundException() when locationNotFound != null:
return locationNotFound(_that);case CharacterNotFoundException() when characterNotFound != null:
return characterNotFound(_that);case ClueNotFoundException() when clueNotFound != null:
return clueNotFound(_that);case EnigmaNotFoundException() when enigmaNotFound != null:
return enigmaNotFound(_that);case InvalidQrCodeException() when invalidQrCode != null:
return invalidQrCode(_that);case PermissionDeniedException() when permissionDenied != null:
return permissionDenied(_that);case NetworkErrorException() when networkError != null:
return networkError(_that);case UnknownException() when unknown != null:
return unknown(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( FileNotFoundException value)  fileNotFound,required TResult Function( FileReadErrorException value)  fileReadError,required TResult Function( FileWriteErrorException value)  fileWriteError,required TResult Function( InvalidJsonException value)  invalidJson,required TResult Function( EpisodeNotFoundException value)  episodeNotFound,required TResult Function( LocationNotFoundException value)  locationNotFound,required TResult Function( CharacterNotFoundException value)  characterNotFound,required TResult Function( ClueNotFoundException value)  clueNotFound,required TResult Function( EnigmaNotFoundException value)  enigmaNotFound,required TResult Function( InvalidQrCodeException value)  invalidQrCode,required TResult Function( PermissionDeniedException value)  permissionDenied,required TResult Function( NetworkErrorException value)  networkError,required TResult Function( UnknownException value)  unknown,}){
final _that = this;
switch (_that) {
case FileNotFoundException():
return fileNotFound(_that);case FileReadErrorException():
return fileReadError(_that);case FileWriteErrorException():
return fileWriteError(_that);case InvalidJsonException():
return invalidJson(_that);case EpisodeNotFoundException():
return episodeNotFound(_that);case LocationNotFoundException():
return locationNotFound(_that);case CharacterNotFoundException():
return characterNotFound(_that);case ClueNotFoundException():
return clueNotFound(_that);case EnigmaNotFoundException():
return enigmaNotFound(_that);case InvalidQrCodeException():
return invalidQrCode(_that);case PermissionDeniedException():
return permissionDenied(_that);case NetworkErrorException():
return networkError(_that);case UnknownException():
return unknown(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( FileNotFoundException value)?  fileNotFound,TResult? Function( FileReadErrorException value)?  fileReadError,TResult? Function( FileWriteErrorException value)?  fileWriteError,TResult? Function( InvalidJsonException value)?  invalidJson,TResult? Function( EpisodeNotFoundException value)?  episodeNotFound,TResult? Function( LocationNotFoundException value)?  locationNotFound,TResult? Function( CharacterNotFoundException value)?  characterNotFound,TResult? Function( ClueNotFoundException value)?  clueNotFound,TResult? Function( EnigmaNotFoundException value)?  enigmaNotFound,TResult? Function( InvalidQrCodeException value)?  invalidQrCode,TResult? Function( PermissionDeniedException value)?  permissionDenied,TResult? Function( NetworkErrorException value)?  networkError,TResult? Function( UnknownException value)?  unknown,}){
final _that = this;
switch (_that) {
case FileNotFoundException() when fileNotFound != null:
return fileNotFound(_that);case FileReadErrorException() when fileReadError != null:
return fileReadError(_that);case FileWriteErrorException() when fileWriteError != null:
return fileWriteError(_that);case InvalidJsonException() when invalidJson != null:
return invalidJson(_that);case EpisodeNotFoundException() when episodeNotFound != null:
return episodeNotFound(_that);case LocationNotFoundException() when locationNotFound != null:
return locationNotFound(_that);case CharacterNotFoundException() when characterNotFound != null:
return characterNotFound(_that);case ClueNotFoundException() when clueNotFound != null:
return clueNotFound(_that);case EnigmaNotFoundException() when enigmaNotFound != null:
return enigmaNotFound(_that);case InvalidQrCodeException() when invalidQrCode != null:
return invalidQrCode(_that);case PermissionDeniedException() when permissionDenied != null:
return permissionDenied(_that);case NetworkErrorException() when networkError != null:
return networkError(_that);case UnknownException() when unknown != null:
return unknown(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( String path)?  fileNotFound,TResult Function( String path)?  fileReadError,TResult Function( String path)?  fileWriteError,TResult Function( String path)?  invalidJson,TResult Function( String episodeId)?  episodeNotFound,TResult Function( String locationId)?  locationNotFound,TResult Function( int characterId)?  characterNotFound,TResult Function( int clueId)?  clueNotFound,TResult Function( int enigmaId)?  enigmaNotFound,TResult Function( String code)?  invalidQrCode,TResult Function( String permission)?  permissionDenied,TResult Function( String message)?  networkError,TResult Function( String message)?  unknown,required TResult orElse(),}) {final _that = this;
switch (_that) {
case FileNotFoundException() when fileNotFound != null:
return fileNotFound(_that.path);case FileReadErrorException() when fileReadError != null:
return fileReadError(_that.path);case FileWriteErrorException() when fileWriteError != null:
return fileWriteError(_that.path);case InvalidJsonException() when invalidJson != null:
return invalidJson(_that.path);case EpisodeNotFoundException() when episodeNotFound != null:
return episodeNotFound(_that.episodeId);case LocationNotFoundException() when locationNotFound != null:
return locationNotFound(_that.locationId);case CharacterNotFoundException() when characterNotFound != null:
return characterNotFound(_that.characterId);case ClueNotFoundException() when clueNotFound != null:
return clueNotFound(_that.clueId);case EnigmaNotFoundException() when enigmaNotFound != null:
return enigmaNotFound(_that.enigmaId);case InvalidQrCodeException() when invalidQrCode != null:
return invalidQrCode(_that.code);case PermissionDeniedException() when permissionDenied != null:
return permissionDenied(_that.permission);case NetworkErrorException() when networkError != null:
return networkError(_that.message);case UnknownException() when unknown != null:
return unknown(_that.message);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( String path)  fileNotFound,required TResult Function( String path)  fileReadError,required TResult Function( String path)  fileWriteError,required TResult Function( String path)  invalidJson,required TResult Function( String episodeId)  episodeNotFound,required TResult Function( String locationId)  locationNotFound,required TResult Function( int characterId)  characterNotFound,required TResult Function( int clueId)  clueNotFound,required TResult Function( int enigmaId)  enigmaNotFound,required TResult Function( String code)  invalidQrCode,required TResult Function( String permission)  permissionDenied,required TResult Function( String message)  networkError,required TResult Function( String message)  unknown,}) {final _that = this;
switch (_that) {
case FileNotFoundException():
return fileNotFound(_that.path);case FileReadErrorException():
return fileReadError(_that.path);case FileWriteErrorException():
return fileWriteError(_that.path);case InvalidJsonException():
return invalidJson(_that.path);case EpisodeNotFoundException():
return episodeNotFound(_that.episodeId);case LocationNotFoundException():
return locationNotFound(_that.locationId);case CharacterNotFoundException():
return characterNotFound(_that.characterId);case ClueNotFoundException():
return clueNotFound(_that.clueId);case EnigmaNotFoundException():
return enigmaNotFound(_that.enigmaId);case InvalidQrCodeException():
return invalidQrCode(_that.code);case PermissionDeniedException():
return permissionDenied(_that.permission);case NetworkErrorException():
return networkError(_that.message);case UnknownException():
return unknown(_that.message);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( String path)?  fileNotFound,TResult? Function( String path)?  fileReadError,TResult? Function( String path)?  fileWriteError,TResult? Function( String path)?  invalidJson,TResult? Function( String episodeId)?  episodeNotFound,TResult? Function( String locationId)?  locationNotFound,TResult? Function( int characterId)?  characterNotFound,TResult? Function( int clueId)?  clueNotFound,TResult? Function( int enigmaId)?  enigmaNotFound,TResult? Function( String code)?  invalidQrCode,TResult? Function( String permission)?  permissionDenied,TResult? Function( String message)?  networkError,TResult? Function( String message)?  unknown,}) {final _that = this;
switch (_that) {
case FileNotFoundException() when fileNotFound != null:
return fileNotFound(_that.path);case FileReadErrorException() when fileReadError != null:
return fileReadError(_that.path);case FileWriteErrorException() when fileWriteError != null:
return fileWriteError(_that.path);case InvalidJsonException() when invalidJson != null:
return invalidJson(_that.path);case EpisodeNotFoundException() when episodeNotFound != null:
return episodeNotFound(_that.episodeId);case LocationNotFoundException() when locationNotFound != null:
return locationNotFound(_that.locationId);case CharacterNotFoundException() when characterNotFound != null:
return characterNotFound(_that.characterId);case ClueNotFoundException() when clueNotFound != null:
return clueNotFound(_that.clueId);case EnigmaNotFoundException() when enigmaNotFound != null:
return enigmaNotFound(_that.enigmaId);case InvalidQrCodeException() when invalidQrCode != null:
return invalidQrCode(_that.code);case PermissionDeniedException() when permissionDenied != null:
return permissionDenied(_that.permission);case NetworkErrorException() when networkError != null:
return networkError(_that.message);case UnknownException() when unknown != null:
return unknown(_that.message);case _:
  return null;

}
}

}

/// @nodoc


class FileNotFoundException implements AppException {
  const FileNotFoundException(this.path);
  

 final  String path;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileNotFoundExceptionCopyWith<FileNotFoundException> get copyWith => _$FileNotFoundExceptionCopyWithImpl<FileNotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileNotFoundException&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'AppException.fileNotFound(path: $path)';
}


}

/// @nodoc
abstract mixin class $FileNotFoundExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $FileNotFoundExceptionCopyWith(FileNotFoundException value, $Res Function(FileNotFoundException) _then) = _$FileNotFoundExceptionCopyWithImpl;
@useResult
$Res call({
 String path
});




}
/// @nodoc
class _$FileNotFoundExceptionCopyWithImpl<$Res>
    implements $FileNotFoundExceptionCopyWith<$Res> {
  _$FileNotFoundExceptionCopyWithImpl(this._self, this._then);

  final FileNotFoundException _self;
  final $Res Function(FileNotFoundException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(FileNotFoundException(
null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class FileReadErrorException implements AppException {
  const FileReadErrorException(this.path);
  

 final  String path;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileReadErrorExceptionCopyWith<FileReadErrorException> get copyWith => _$FileReadErrorExceptionCopyWithImpl<FileReadErrorException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileReadErrorException&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'AppException.fileReadError(path: $path)';
}


}

/// @nodoc
abstract mixin class $FileReadErrorExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $FileReadErrorExceptionCopyWith(FileReadErrorException value, $Res Function(FileReadErrorException) _then) = _$FileReadErrorExceptionCopyWithImpl;
@useResult
$Res call({
 String path
});




}
/// @nodoc
class _$FileReadErrorExceptionCopyWithImpl<$Res>
    implements $FileReadErrorExceptionCopyWith<$Res> {
  _$FileReadErrorExceptionCopyWithImpl(this._self, this._then);

  final FileReadErrorException _self;
  final $Res Function(FileReadErrorException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(FileReadErrorException(
null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class FileWriteErrorException implements AppException {
  const FileWriteErrorException(this.path);
  

 final  String path;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileWriteErrorExceptionCopyWith<FileWriteErrorException> get copyWith => _$FileWriteErrorExceptionCopyWithImpl<FileWriteErrorException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileWriteErrorException&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'AppException.fileWriteError(path: $path)';
}


}

/// @nodoc
abstract mixin class $FileWriteErrorExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $FileWriteErrorExceptionCopyWith(FileWriteErrorException value, $Res Function(FileWriteErrorException) _then) = _$FileWriteErrorExceptionCopyWithImpl;
@useResult
$Res call({
 String path
});




}
/// @nodoc
class _$FileWriteErrorExceptionCopyWithImpl<$Res>
    implements $FileWriteErrorExceptionCopyWith<$Res> {
  _$FileWriteErrorExceptionCopyWithImpl(this._self, this._then);

  final FileWriteErrorException _self;
  final $Res Function(FileWriteErrorException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(FileWriteErrorException(
null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class InvalidJsonException implements AppException {
  const InvalidJsonException(this.path);
  

 final  String path;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InvalidJsonExceptionCopyWith<InvalidJsonException> get copyWith => _$InvalidJsonExceptionCopyWithImpl<InvalidJsonException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InvalidJsonException&&(identical(other.path, path) || other.path == path));
}


@override
int get hashCode => Object.hash(runtimeType,path);

@override
String toString() {
  return 'AppException.invalidJson(path: $path)';
}


}

/// @nodoc
abstract mixin class $InvalidJsonExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $InvalidJsonExceptionCopyWith(InvalidJsonException value, $Res Function(InvalidJsonException) _then) = _$InvalidJsonExceptionCopyWithImpl;
@useResult
$Res call({
 String path
});




}
/// @nodoc
class _$InvalidJsonExceptionCopyWithImpl<$Res>
    implements $InvalidJsonExceptionCopyWith<$Res> {
  _$InvalidJsonExceptionCopyWithImpl(this._self, this._then);

  final InvalidJsonException _self;
  final $Res Function(InvalidJsonException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? path = null,}) {
  return _then(InvalidJsonException(
null == path ? _self.path : path // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class EpisodeNotFoundException implements AppException {
  const EpisodeNotFoundException(this.episodeId);
  

 final  String episodeId;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EpisodeNotFoundExceptionCopyWith<EpisodeNotFoundException> get copyWith => _$EpisodeNotFoundExceptionCopyWithImpl<EpisodeNotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EpisodeNotFoundException&&(identical(other.episodeId, episodeId) || other.episodeId == episodeId));
}


@override
int get hashCode => Object.hash(runtimeType,episodeId);

@override
String toString() {
  return 'AppException.episodeNotFound(episodeId: $episodeId)';
}


}

/// @nodoc
abstract mixin class $EpisodeNotFoundExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $EpisodeNotFoundExceptionCopyWith(EpisodeNotFoundException value, $Res Function(EpisodeNotFoundException) _then) = _$EpisodeNotFoundExceptionCopyWithImpl;
@useResult
$Res call({
 String episodeId
});




}
/// @nodoc
class _$EpisodeNotFoundExceptionCopyWithImpl<$Res>
    implements $EpisodeNotFoundExceptionCopyWith<$Res> {
  _$EpisodeNotFoundExceptionCopyWithImpl(this._self, this._then);

  final EpisodeNotFoundException _self;
  final $Res Function(EpisodeNotFoundException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? episodeId = null,}) {
  return _then(EpisodeNotFoundException(
null == episodeId ? _self.episodeId : episodeId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LocationNotFoundException implements AppException {
  const LocationNotFoundException(this.locationId);
  

 final  String locationId;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LocationNotFoundExceptionCopyWith<LocationNotFoundException> get copyWith => _$LocationNotFoundExceptionCopyWithImpl<LocationNotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LocationNotFoundException&&(identical(other.locationId, locationId) || other.locationId == locationId));
}


@override
int get hashCode => Object.hash(runtimeType,locationId);

@override
String toString() {
  return 'AppException.locationNotFound(locationId: $locationId)';
}


}

/// @nodoc
abstract mixin class $LocationNotFoundExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $LocationNotFoundExceptionCopyWith(LocationNotFoundException value, $Res Function(LocationNotFoundException) _then) = _$LocationNotFoundExceptionCopyWithImpl;
@useResult
$Res call({
 String locationId
});




}
/// @nodoc
class _$LocationNotFoundExceptionCopyWithImpl<$Res>
    implements $LocationNotFoundExceptionCopyWith<$Res> {
  _$LocationNotFoundExceptionCopyWithImpl(this._self, this._then);

  final LocationNotFoundException _self;
  final $Res Function(LocationNotFoundException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? locationId = null,}) {
  return _then(LocationNotFoundException(
null == locationId ? _self.locationId : locationId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class CharacterNotFoundException implements AppException {
  const CharacterNotFoundException(this.characterId);
  

 final  int characterId;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CharacterNotFoundExceptionCopyWith<CharacterNotFoundException> get copyWith => _$CharacterNotFoundExceptionCopyWithImpl<CharacterNotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CharacterNotFoundException&&(identical(other.characterId, characterId) || other.characterId == characterId));
}


@override
int get hashCode => Object.hash(runtimeType,characterId);

@override
String toString() {
  return 'AppException.characterNotFound(characterId: $characterId)';
}


}

/// @nodoc
abstract mixin class $CharacterNotFoundExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $CharacterNotFoundExceptionCopyWith(CharacterNotFoundException value, $Res Function(CharacterNotFoundException) _then) = _$CharacterNotFoundExceptionCopyWithImpl;
@useResult
$Res call({
 int characterId
});




}
/// @nodoc
class _$CharacterNotFoundExceptionCopyWithImpl<$Res>
    implements $CharacterNotFoundExceptionCopyWith<$Res> {
  _$CharacterNotFoundExceptionCopyWithImpl(this._self, this._then);

  final CharacterNotFoundException _self;
  final $Res Function(CharacterNotFoundException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? characterId = null,}) {
  return _then(CharacterNotFoundException(
null == characterId ? _self.characterId : characterId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class ClueNotFoundException implements AppException {
  const ClueNotFoundException(this.clueId);
  

 final  int clueId;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ClueNotFoundExceptionCopyWith<ClueNotFoundException> get copyWith => _$ClueNotFoundExceptionCopyWithImpl<ClueNotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ClueNotFoundException&&(identical(other.clueId, clueId) || other.clueId == clueId));
}


@override
int get hashCode => Object.hash(runtimeType,clueId);

@override
String toString() {
  return 'AppException.clueNotFound(clueId: $clueId)';
}


}

/// @nodoc
abstract mixin class $ClueNotFoundExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $ClueNotFoundExceptionCopyWith(ClueNotFoundException value, $Res Function(ClueNotFoundException) _then) = _$ClueNotFoundExceptionCopyWithImpl;
@useResult
$Res call({
 int clueId
});




}
/// @nodoc
class _$ClueNotFoundExceptionCopyWithImpl<$Res>
    implements $ClueNotFoundExceptionCopyWith<$Res> {
  _$ClueNotFoundExceptionCopyWithImpl(this._self, this._then);

  final ClueNotFoundException _self;
  final $Res Function(ClueNotFoundException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? clueId = null,}) {
  return _then(ClueNotFoundException(
null == clueId ? _self.clueId : clueId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class EnigmaNotFoundException implements AppException {
  const EnigmaNotFoundException(this.enigmaId);
  

 final  int enigmaId;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$EnigmaNotFoundExceptionCopyWith<EnigmaNotFoundException> get copyWith => _$EnigmaNotFoundExceptionCopyWithImpl<EnigmaNotFoundException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is EnigmaNotFoundException&&(identical(other.enigmaId, enigmaId) || other.enigmaId == enigmaId));
}


@override
int get hashCode => Object.hash(runtimeType,enigmaId);

@override
String toString() {
  return 'AppException.enigmaNotFound(enigmaId: $enigmaId)';
}


}

/// @nodoc
abstract mixin class $EnigmaNotFoundExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $EnigmaNotFoundExceptionCopyWith(EnigmaNotFoundException value, $Res Function(EnigmaNotFoundException) _then) = _$EnigmaNotFoundExceptionCopyWithImpl;
@useResult
$Res call({
 int enigmaId
});




}
/// @nodoc
class _$EnigmaNotFoundExceptionCopyWithImpl<$Res>
    implements $EnigmaNotFoundExceptionCopyWith<$Res> {
  _$EnigmaNotFoundExceptionCopyWithImpl(this._self, this._then);

  final EnigmaNotFoundException _self;
  final $Res Function(EnigmaNotFoundException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? enigmaId = null,}) {
  return _then(EnigmaNotFoundException(
null == enigmaId ? _self.enigmaId : enigmaId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class InvalidQrCodeException implements AppException {
  const InvalidQrCodeException(this.code);
  

 final  String code;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InvalidQrCodeExceptionCopyWith<InvalidQrCodeException> get copyWith => _$InvalidQrCodeExceptionCopyWithImpl<InvalidQrCodeException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InvalidQrCodeException&&(identical(other.code, code) || other.code == code));
}


@override
int get hashCode => Object.hash(runtimeType,code);

@override
String toString() {
  return 'AppException.invalidQrCode(code: $code)';
}


}

/// @nodoc
abstract mixin class $InvalidQrCodeExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $InvalidQrCodeExceptionCopyWith(InvalidQrCodeException value, $Res Function(InvalidQrCodeException) _then) = _$InvalidQrCodeExceptionCopyWithImpl;
@useResult
$Res call({
 String code
});




}
/// @nodoc
class _$InvalidQrCodeExceptionCopyWithImpl<$Res>
    implements $InvalidQrCodeExceptionCopyWith<$Res> {
  _$InvalidQrCodeExceptionCopyWithImpl(this._self, this._then);

  final InvalidQrCodeException _self;
  final $Res Function(InvalidQrCodeException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? code = null,}) {
  return _then(InvalidQrCodeException(
null == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class PermissionDeniedException implements AppException {
  const PermissionDeniedException(this.permission);
  

 final  String permission;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PermissionDeniedExceptionCopyWith<PermissionDeniedException> get copyWith => _$PermissionDeniedExceptionCopyWithImpl<PermissionDeniedException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PermissionDeniedException&&(identical(other.permission, permission) || other.permission == permission));
}


@override
int get hashCode => Object.hash(runtimeType,permission);

@override
String toString() {
  return 'AppException.permissionDenied(permission: $permission)';
}


}

/// @nodoc
abstract mixin class $PermissionDeniedExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $PermissionDeniedExceptionCopyWith(PermissionDeniedException value, $Res Function(PermissionDeniedException) _then) = _$PermissionDeniedExceptionCopyWithImpl;
@useResult
$Res call({
 String permission
});




}
/// @nodoc
class _$PermissionDeniedExceptionCopyWithImpl<$Res>
    implements $PermissionDeniedExceptionCopyWith<$Res> {
  _$PermissionDeniedExceptionCopyWithImpl(this._self, this._then);

  final PermissionDeniedException _self;
  final $Res Function(PermissionDeniedException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? permission = null,}) {
  return _then(PermissionDeniedException(
null == permission ? _self.permission : permission // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class NetworkErrorException implements AppException {
  const NetworkErrorException(this.message);
  

 final  String message;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NetworkErrorExceptionCopyWith<NetworkErrorException> get copyWith => _$NetworkErrorExceptionCopyWithImpl<NetworkErrorException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NetworkErrorException&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AppException.networkError(message: $message)';
}


}

/// @nodoc
abstract mixin class $NetworkErrorExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $NetworkErrorExceptionCopyWith(NetworkErrorException value, $Res Function(NetworkErrorException) _then) = _$NetworkErrorExceptionCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$NetworkErrorExceptionCopyWithImpl<$Res>
    implements $NetworkErrorExceptionCopyWith<$Res> {
  _$NetworkErrorExceptionCopyWithImpl(this._self, this._then);

  final NetworkErrorException _self;
  final $Res Function(NetworkErrorException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(NetworkErrorException(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class UnknownException implements AppException {
  const UnknownException(this.message);
  

 final  String message;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnknownExceptionCopyWith<UnknownException> get copyWith => _$UnknownExceptionCopyWithImpl<UnknownException>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnknownException&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AppException.unknown(message: $message)';
}


}

/// @nodoc
abstract mixin class $UnknownExceptionCopyWith<$Res> implements $AppExceptionCopyWith<$Res> {
  factory $UnknownExceptionCopyWith(UnknownException value, $Res Function(UnknownException) _then) = _$UnknownExceptionCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$UnknownExceptionCopyWithImpl<$Res>
    implements $UnknownExceptionCopyWith<$Res> {
  _$UnknownExceptionCopyWithImpl(this._self, this._then);

  final UnknownException _self;
  final $Res Function(UnknownException) _then;

/// Create a copy of AppException
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(UnknownException(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
